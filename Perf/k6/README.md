# k6 Demo
The included [script](./script.js) provides three different scenarios for examples in testing performance.  
The demo script will test:
  - a standard HTML page: `testK6Page()` (to mimic the loading of a static asset)
  - a collection of API endpoints: `testK6Apis()` (to mimic the loading of a data-driven page) 
  - an API endpoint that will fail some of the requests (disabled by default): `testRandomPeopleApi()` (to mimic an eventually failing endpoint)

>**NOTE:** In order to test the failing API endpoint, you will need to uncomment line **122**.

## Overview
[k6](http://k6.io) is an Open Source performance testing platform. k6 is extremely easy to use and requires very little development knowledge. The included [script](./script.js) is designed to give you insights into creating the basic performance tests against three types of resources - static assets, APIs, and eventually-failing APIs (just to see how k6 reports failures). Our intention is for you to have a resource that can be quickly adapted to your environment so that executing load and stress tests can be done fairly effortlessly.

We have attempted to provide as many comments as possible throughout the script so that you can understand the functionality of its various components. At a high level, the script can be broken down into four major sections: defining performance counters, script options, creating tests, and the entry point. With the included comments, along with the below content, you should be able to adequately modify the script to test your custom endpoints and/or application.

### Performance Counters
k6 offers four different types of [custom metrics](https://k6.io/docs/javascript-api/k6-metrics/). In this demo script, we are only focused on two - Trends and Rates. The trends and rates that we have configured will allow us to track various custom metrics across our tests. In our case, for each suite of tests, we are tracking the requests duration and the number of errors encountered. 

For each test suite, we capture the duration by getting the current date/time _before_ the request and subtracting it from the date/time _after_ the test as completed. By adding it to the trend, we can monitor the duration of requests as the load increases/decreases. 

Additionally, we capture the rate of errors that each test suite generates. Every time we encounter an error in the request, we add 1 to the rate counter. A percentage is then generated by the dividing the total number of errors by the errors for this specific test suite. The logic could be a little more robust, however, keep in mind that our goal with this script is to keep it simple and accelerate your ramp-up time.

### Script Options
There are _many_ different [options](https://k6.io/docs/using-k6/options/) for customizing your k6 tests run. However, for this demo, we are only concerned with two - stages and thresholds.

Stages allow us to mimic a stair-stepped approach to introducing load on our system. For stages, there are a minimum of two different values you will need to configure for each - the duration of the stage and the number of virtual users (VUs). Keep in mind that the _target_ is **NOT** the number of total requests, but the number of total virtual users. Therefore, if you are running multiple tests, and each test contains multiple HTTP requests, the each user will be performing all of those requests randomly throughout your load test.

Thresholds allow you to set your performance SLAs as determined by the business. In the case of this demo, the business has determined that no single request should take longer than 10 seconds, and while the system is under 90% of our target load, requests should not exceed 2 seconds. Furthermore, while the system is under 95% of our target load, requests should not exceed 5 seconds, understanding that as load increases, the HTTP request duration may also increase. Obviously, these are very generous thresholds, but you can adjust them to your business requirements. Just remember that the values specified here are in _milliseconds_. Lastly, we have specified that we are only allowing for 10% of our total requests to fail.

One thing worth noting, if none of our tests encounter failed requests, k6 will not tell us. The only time k6 will report the failure rate is when a test actually fails.

### Creating Tests
As stated in the introduction, the test script contains three demo suites to illustrate various ways to perform tests. The comments should be self-explanatory, but the tests show how to test static assets (`testK6Page()`), which can be images, stylesheets, scripts, etc., and an array of API endpoints (`testK6Apis()`). The latter is necessary when testing a data-driven page like a dashboard. (By the way, if your dashboard contains scripts, stylesheets, images, you may want to include those to gain visibility into the total time required to download your page's assets and data.) 

Testing static assets can be trivial, especially if those assets are hosted on CDNs. If your static resources are not hosted on CDNs, however, testing the delivery of these assets is still considered a high priority as their delivery contributes to your networks' congestion and resource utilization.

The third test (`testRandomPeopleApi()`) is commented out (line 122) by default as it will produce failures after returning 2,000 random users within one minute. The script will continue to run, but reporting will show the failed executions. This third test is to demonstrate the possibility of a system under test becoming overloaded or congested and, thereby, eventually failing to respond to requests. (In our case, the Random People service only allows you to request 2,000 users per minute, but this, again, is for demonstration purposes. However, if your system utilizes a 3rd-party API that limits requests, this may be a real scenario for you.)

### Entry Point
The last section (`export default function() {...}`) of our demo script is the main entry point for k6 execution. k6 calls this function to execute our tests, and it is from this function that we call our individual test suites.

One thing to note is that, in order to mimic the mouse clicks of an actual user, we `sleep()` 1 second before each test. Again, this mimics the navigation of a user on our site _and_ reduces the potential false positive of a DDoS attack against our system under test.

## Execution
There are two ways to execute the k6 script. Regardless of the method you choose, you will still need to either clone this repository locally, or download the [script](./script.js).

### Docker Container
If you are running Docker, k6 is available as a container. It is possible to execute the tests in the script by injecting it into the container runtime.

Provided that you have Docker installed (and running) locally and the script is downloaded to your current folder:
```bash
docker run -i loadimpact/k6 run -<script.js
```

### Standalone
If you find yourself writing k6 scripts often, you may prefer to [install k6 locally](https://k6.io/docs/getting-started/installation/). By installing it on your machine, you can take advantage of additional benefits like colorized reporting and multiple files for test suites, which can be extremely beneficial compared to a single file for all tests.

After installing k6, run it locally with the following:
```bash
k6 run script.js
```
